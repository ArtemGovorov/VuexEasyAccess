{"version":3,"file":"index.min.js","sources":["../src/objectDeepValueUtils.js","../src/storeAccess.js","../src/index.js"],"sourcesContent":["\nimport { isArray } from 'is-what'\n\n/**\n * Returns the keys of a path\n *\n * @param   {string} path   a/path/like.this\n * @returns {array} with keys\n */\nfunction getKeysFromPath (path) {\n  if (!path) return []\n  return path.match(/\\w+/g)\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param {object} target an object to wherefrom to retrieve the deep reference of\n * @param {string} path   'path/to.prop'\n *\n * @returns {object} the property which was requested\n */\nfunction getDeepRef (target = {}, path) {\n  let keys = getKeysFromPath(path)\n  let obj = target\n  while (obj && keys.length > 1) {\n    obj = obj[keys.shift()]\n  }\n  let key = keys.shift()\n  if (obj && obj.hasOwnProperty(key)) {\n    return obj[key]\n  }\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to get the value of\n * @param   {string} path     'path/to/prop.subprop'\n *\n * @returns {object}          the property's value\n */\nfunction getDeepValue (target, path) {\n  return getDeepRef(target, path)\n}\n\n/**\n * Sets a value to a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to/prop.subprop'\n * @param   {*}      value    the value to set\n *\n * @returns {object}          the original target object\n */\nfunction setDeepValue (target, path, value) {\n  const keys = getKeysFromPath(path)\n  const lastKey = keys.pop()\n  const deepRef = getDeepRef(target, keys.join())\n  if (deepRef && deepRef.hasOwnProperty(lastKey)) {\n    deepRef[lastKey] = value\n  }\n  return target\n}\n\n/**\n * Pops a value of an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path.to.sub.prop'\n *\n * @returns {*}               the popped value\n */\nfunction popDeepValue (target, path) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.pop()\n}\n/**\n * Pushes a value in an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to.sub.prop'\n * @param   {*}      value    the value to set\n *\n * @returns {number}          the new length of the array\n */\nfunction pushDeepValue (target, path, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.push(value)\n}\n/**\n * Splice into an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target       the Object to set the value on\n * @param   {string} path         'path/to.sub.prop'\n * @param   {*}      value        the value to splice in\n * @param   {number} index        the index to splice in the value, defaults to 0\n * @param   {number} deleteCount  the amount of items to delete, defaults to 0\n *\n * @returns {array}              an array containing the deleted elements\n */\nfunction spliceDeepValue (target, path, index = 0, deleteCount = 0, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.splice(index, deleteCount, value)\n}\n\nexport { getDeepRef, setDeepValue, getDeepValue, popDeepValue, pushDeepValue, spliceDeepValue }\n","/**\n * Vuex Easy Access plugin\n * Unified syntax with simple set() and get() store access + auto generate mutations!\n *\n * @author     Luca Ban\n * @contact    https://lucaban.com\n */\n\nimport { setDeepValue, getDeepValue, popDeepValue, pushDeepValue, spliceDeepValue } from './objectDeepValueUtils'\nimport { isObject, isArray } from 'is-what'\n\n/**\n * Creates the mutations for each property of the object passed recursively\n *\n * @param   {object} propParent an Object of which all props will get a mutation\n * @param   {string} path       the path taken until the current propParent instance\n *\n * @returns {object}            all mutations for each property.\n */\nfunction makeMutationsForAllProps(propParent, path) {\n  if (!isObject(propParent)) return {}\n  return Object.keys(propParent)\n  .reduce((mutations, prop) => {\n    let propPath = (!path)\n      ? prop\n      : path + '.' + prop\n    let name = 'SET_' + propPath.toUpperCase()\n    mutations[name] = (state, newVal) => {\n      return setDeepValue(state, propPath, newVal)\n    }\n    let propValue = propParent[prop]\n    // If the prop is an object, make the children setters as well\n    if (isObject(propValue)) {\n      let childrenMutations = makeMutationsForAllProps(propValue, propPath)\n      mutations = {...mutations, ...childrenMutations}\n    }\n    // If the prop is an array, make array mutations as well\n    if (isArray(propValue)) {\n      let pop = 'POP_' + propPath.toUpperCase()\n      mutations[pop] = (state) => {\n        return popDeepValue(state, propPath)\n      }\n      let push = 'PUSH_' + propPath.toUpperCase()\n      mutations[push] = (state, value) => {\n        return pushDeepValue(state, propPath, value)\n      }\n      let splice = 'SPLICE_' + propPath.toUpperCase()\n      mutations[splice] = (state, index, deleteCount, value) => {\n        return spliceDeepValue(state, propPath, index, deleteCount, value)\n      }\n    }\n    return mutations\n  }, {})\n}\n\n/**\n * Creates all mutations for the state of a module.\n * Usage:\n * commit('module/path/SET_PATH.TO.PROP', newValue)\n * Import method:\n * mutations {\n *   ...defaultMutations (initialState)\n * }\n *\n * @param   {object} initialState   the initial state of a module\n *\n * @returns {object}                all mutations for the state\n */\nfunction defaultMutations (initialState) {\n  return makeMutationsForAllProps(initialState)\n}\n\n/**\n * Creates a setter function in the store to set any state value\n * Usage:\n * `set('module/path/path.to.prop', newValue)`\n * it will check first for existence of: `dispatch('module/path/setPath.to.prop')`\n * if non existant it will execute: `commit('module/path/SET_PATH.TO.PROP', newValue)`\n * Import method:\n * `store.set = (path, payload) => { return defaultSetter(path, payload, store) }`\n *\n * @param   {string}   path     the path of the prop to set eg. 'info/user/favColours.primary'\n * @param   {*}        payload  the payload to set the prop to\n * @param   {object}   store    the store to attach\n *\n * @returns {function}          dispatch or commit\n */\nfunction defaultSetter (path, payload, store) {\n  // path = 'info/user/favColours.primary'\n  const pArr = path.split('/')\n  // ['info', 'user', 'favColours.primary']\n  const props = pArr.pop()\n  // 'favColours.primary'\n  const modulePath = (pArr.length)\n    ? pArr.join('/') + '/'\n    : ''\n  // 'info/user'\n  const actionName = 'set' + props[0].toUpperCase() + props.substring(1)\n  // 'setFavColours.primary'\n  const actionPath = modulePath + actionName\n  // 'info/user/setFavColours.primary'\n  const action = store._actions[actionPath]\n  if (action) {\n    return store.dispatch(actionPath, payload)\n  }\n  const mutationPath = modulePath + 'SET_' + props.toUpperCase()\n  return store.commit(mutationPath, payload)\n}\n\n/**\n * Creates a getter function in the store to set any state value\n * Usage:\n * `get('module/path/path.to.prop')`\n * it will check first for existence of: `getters['module/path/path.to.prop']`\n * if non existant it will return: `state.module.path.path.to.prop`\n * Import method:\n * `store.get = (path) => { return defaultGetter(path, store) }`\n *\n * @param   {string}   path     the path of the prop to get eg. 'info/user/favColours.primary'\n * @param   {object}   store    the store to attach\n *\n * @returns {function}          getter or state\n */\nfunction defaultGetter (path, store) {\n  const getterExists = store.getters.hasOwnProperty(path)\n  if (getterExists) return store.getters[path]\n  return getDeepValue(store.state, path)\n}\n\nexport { defaultMutations, defaultSetter, defaultGetter }\n","/**\n * Vuex Easy Access plugin\n * Unified syntax with simple set() and get() store access + auto generate mutations!\n *\n * @author     Luca Ban\n * @contact    https://lucaban.com\n */\n\nimport { defaultMutations, defaultSetter, defaultGetter } from './storeAccess'\nimport { getDeepRef } from './objectDeepValueUtils'\n\nmodule.exports = { defaultMutations, defaultSetter, defaultGetter, getDeepRef }\n"],"names":["getKeysFromPath","path","match","getDeepRef","target","keys","obj","length","shift","key","hasOwnProperty","makeMutationsForAllProps","propParent","isObject","Object","reduce","mutations","prop","propPath","toUpperCase","state","newVal","value","lastKey","pop","deepRef","join","propValue","childrenMutations","isArray","popDeepValue","push","pushDeepValue","index","deleteCount","splice","spliceDeepValue","module","exports","defaultMutations","initialState","defaultSetter","payload","store","pArr","split","props","modulePath","actionPath","substring","_actions","dispatch","mutationPath","commit","defaultGetter","getters"],"mappings":"iMASA,SAASA,EAAiBC,UACnBA,EACEA,EAAKC,MAAM,QADA,GAYpB,SAASC,YAAYC,yDAAS,GACxBC,EAAOL,gBACPM,EAAMF,EACHE,GAAqB,EAAdD,EAAKE,UACXD,EAAID,EAAKG,aAEbC,EAAMJ,EAAKG,WACXF,GAAOA,EAAII,eAAeD,UACrBH,EAAIG,2KCXf,SAASE,EAAyBC,EAAYX,UACvCY,WAASD,GACPE,OAAOT,KAAKO,GAClBG,OAAO,SAACC,EAAWC,OACdC,EAAajB,EAEbA,EAAO,IAAMgB,EADbA,IAEO,OAASC,EAASC,eACX,SAACC,EAAOC,UD4BPjB,EC3BGgB,ED2BWE,EC3BMD,ED4BnChB,EAAOL,EC5BkBkB,GD6BzBK,EAAUlB,EAAKmB,OACfC,EAAUtB,EAAWC,EAAQC,EAAKqB,UACzBD,EAAQf,eAAea,OAC5BA,GAAWD,GAEdlB,EAPT,IAAuBA,EAAckB,EAC7BjB,EACAkB,EACAE,OC5BAE,EAAYf,EAAWK,MAEvBJ,WAASc,GAAY,KACnBC,EAAoBjB,EAAyBgB,EAAWT,UAC5CF,EAAcY,GAG5BC,UAAQF,OACA,OAAST,EAASC,eACX,SAACC,UDkCxB,SAAuBhB,EAAQH,OACvBwB,EAAUtB,EAAWC,EAAQH,MAC9B4B,UAAQJ,UACNA,EAAQD,MCpCFM,CAAaV,EAAOF,MAElB,QAAUA,EAASC,eACZ,SAACC,EAAOE,UD4ChC,SAAwBlB,EAAQH,EAAMqB,OAC9BG,EAAUtB,EAAWC,EAAQH,MAC9B4B,UAAQJ,UACNA,EAAQM,KAAKT,GC9CPU,CAAcZ,EAAOF,EAAUI,MAE3B,UAAYJ,EAASC,eACd,SAACC,EAAOa,EAAOC,EAAaZ,UDwDtD,SAA0BlB,EAAQH,OAAMgC,yDAAQ,EAAGC,yDAAc,EAAGZ,eAC5DG,EAAUtB,EAAWC,EAAQH,MAC9B4B,UAAQJ,UACNA,EAAQU,OAAOF,EAAOC,EAAaZ,GC1D7Bc,CAAgBhB,EAAOF,EAAUe,EAAOC,EAAaZ,YAGzDN,GACN,IAhC+B,GCTpCqB,OAAOC,QAAU,CAAEC,iBDyDnB,SAA2BC,UAClB7B,EAAyB6B,IC1DGC,cD4ErC,SAAwBxC,EAAMyC,EAASC,OAE/BC,EAAO3C,EAAK4C,MAAM,KAElBC,EAAQF,EAAKpB,MAEbuB,EAAcH,EAAKrC,OACrBqC,EAAKlB,KAAK,KAAO,IACjB,GAIEsB,EAAaD,EAFA,MAAQD,EAAM,GAAG3B,cAAgB2B,EAAMG,UAAU,MAIrDN,EAAMO,SAASF,UAErBL,EAAMQ,SAASH,EAAYN,OAE9BU,EAAeL,EAAa,OAASD,EAAM3B,qBAC1CwB,EAAMU,OAAOD,EAAcV,IC/FgBY,cDgHpD,SAAwBrD,EAAM0C,UACPA,EAAMY,QAAQ7C,eAAeT,GACzB0C,EAAMY,QAAQtD,GDlFhCE,ECmFawC,EAAMvB,MAAOnB,ICnHgCE"}