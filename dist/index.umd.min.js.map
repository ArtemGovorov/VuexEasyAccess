{"version":3,"file":"index.umd.min.js","sources":["../src/objectDeepValueUtils.js","../src/storeAccess.js","../src/defaultConfig.js","../src/index.js"],"sourcesContent":["import { isArray } from 'is-what'\n\n/**\n * Returns the keys of a path\n *\n * @param   {string} path   a/path/like.this\n * @returns {array} with keys\n */\nfunction getKeysFromPath (path) {\n  if (!path) return []\n  return path.match(/\\w+/g)\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param {object} target an object to wherefrom to retrieve the deep reference of\n * @param {string} path   'path/to.prop'\n *\n * @returns {object} the property which was requested\n */\nfunction getDeepRef (target = {}, path) {\n  let keys = getKeysFromPath(path)\n  if (!keys.length) return target\n  let obj = target\n  while (obj && keys.length > 1) {\n    obj = obj[keys.shift()]\n  }\n  let key = keys.shift()\n  if (obj && obj.hasOwnProperty(key)) {\n    return obj[key]\n  }\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to get the value of\n * @param   {string} path     'path/to/prop.subprop'\n *\n * @returns {object}          the property's value\n */\nfunction getDeepValue (target, path) {\n  return getDeepRef(target, path)\n}\n\n/**\n * Sets a value to a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to/prop.subprop'\n * @param   {*}      value    the value to set\n *\n * @returns {object}          the original target object\n */\nfunction setDeepValue (target, path, value) {\n  const keys = getKeysFromPath(path)\n  const lastKey = keys.pop()\n  const deepRef = getDeepRef(target, keys.join())\n  if (deepRef && deepRef.hasOwnProperty(lastKey)) {\n    deepRef[lastKey] = value\n  }\n  return target\n}\n\n/**\n * Pops a value of an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path.to.sub.prop'\n *\n * @returns {*}               the popped value\n */\nfunction popDeepValue (target, path) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.pop()\n}\n/**\n * Pushes a value in an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to.sub.prop'\n * @param   {*}      value    the value to set\n *\n * @returns {number}          the new length of the array\n */\nfunction pushDeepValue (target, path, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.push(value)\n}\n/**\n * Splice into an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target       the Object to set the value on\n * @param   {string} path         'path/to.sub.prop'\n * @param   {*}      value        the value to splice in\n * @param   {number} index        the index to splice in the value, defaults to 0\n * @param   {number} deleteCount  the amount of items to delete, defaults to 0\n *\n * @returns {array}              an array containing the deleted elements\n */\nfunction spliceDeepValue (target, path, index = 0, deleteCount = 0, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.splice(index, deleteCount, value)\n}\n\nexport { getDeepRef, getKeysFromPath, setDeepValue, getDeepValue, popDeepValue, pushDeepValue, spliceDeepValue }\n","/**\n * Vuex Easy Access plugin\n * Unified syntax with simple set() and get() store access + auto generate mutations!\n *\n * @author     Luca Ban\n * @contact    https://lucaban.com\n */\n\nimport { setDeepValue, getDeepValue, popDeepValue, pushDeepValue, spliceDeepValue } from './objectDeepValueUtils'\nimport { isObject, isArray } from 'is-what'\n\n/**\n * Creates the mutations for each property of the object passed recursively\n *\n * @param   {object} propParent an Object of which all props will get a mutation\n * @param   {string} path       the path taken until the current propParent instance\n *\n * @returns {object}            all mutations for each property.\n */\nfunction makeMutationsForAllProps(propParent, path) {\n  if (!isObject(propParent)) return {}\n  return Object.keys(propParent)\n  .reduce((mutations, prop) => {\n    if (prop[0] === '_') return mutations\n    let propPath = (!path)\n      ? prop\n      : path + '.' + prop\n    let name = 'SET_' + propPath.toUpperCase()\n    mutations[name] = (state, newVal) => {\n      return setDeepValue(state, propPath, newVal)\n    }\n    let propValue = propParent[prop]\n    // If the prop is an object, make the children setters as well\n    if (isObject(propValue)) {\n      let childrenMutations = makeMutationsForAllProps(propValue, propPath)\n      mutations = {...mutations, ...childrenMutations}\n    }\n    // If the prop is an array, make array mutations as well\n    if (isArray(propValue)) {\n      let pop = 'POP_' + propPath.toUpperCase()\n      mutations[pop] = (state) => {\n        return popDeepValue(state, propPath)\n      }\n      let push = 'PUSH_' + propPath.toUpperCase()\n      mutations[push] = (state, value) => {\n        return pushDeepValue(state, propPath, value)\n      }\n      let splice = 'SPLICE_' + propPath.toUpperCase()\n      mutations[splice] = (state, index, deleteCount, value) => {\n        return spliceDeepValue(state, propPath, index, deleteCount, value)\n      }\n    }\n    return mutations\n  }, {})\n}\n\n/**\n * Creates all mutations for the state of a module.\n * Usage:\n * commit('module/path/SET_PATH.TO.PROP', newValue)\n * Import method:\n * mutations {\n *   ...defaultMutations (initialState)\n * }\n *\n * @param   {object} initialState   the initial state of a module\n *\n * @returns {object}                all mutations for the state\n */\nfunction defaultMutations (initialState) {\n  return makeMutationsForAllProps(initialState)\n}\n\n/**\n * Creates a setter function in the store to set any state value\n * Usage:\n * `set('module/path/path.to.prop', newValue)`\n * it will check first for existence of: `dispatch('module/path/setPath.to.prop')`\n * if non existant it will execute: `commit('module/path/SET_PATH.TO.PROP', newValue)`\n * Import method:\n * `store.set = (path, payload) => { return defaultSetter(path, payload, store) }`\n *\n * @param   {string}   path     the path of the prop to set eg. 'info/user/favColours.primary'\n * @param   {*}        payload  the payload to set the prop to\n * @param   {object}   store    the store to attach\n *\n * @returns {function}          dispatch or commit\n */\nfunction defaultSetter (path, payload, store, vuexEasyFirestore) {\n  // path = 'info/user/favColours.primary'\n  const pArr = path.split('/')\n  // ['info', 'user', 'favColours.primary']\n  const props = pArr.pop()\n  // 'favColours.primary'\n  const modulePath = (pArr.length)\n    ? pArr.join('/') + '/'\n    : ''\n  // 'info/user/'\n  const actionName = 'set' + props[0].toUpperCase() + props.substring(1)\n  // 'setFavColours.primary'\n  const actionPath = modulePath + actionName\n  // 'info/user/setFavColours.primary'\n  const actionExists = store._actions[actionPath]\n  if (actionExists) {\n    return store.dispatch(actionPath, payload)\n  }\n  if (vuexEasyFirestore) {\n    // 'info/user/set', {favColours: {primary: payload}}'\n    const pathIsModule = store._modulesNamespaceMap[path + '/']\n    const firestoreActionPath = (pathIsModule)\n      ? path + '/set'\n      : modulePath + 'set'\n    const newPayload = (pathIsModule)\n      ? payload\n      : {}\n    if (!pathIsModule) newPayload[props] = payload\n    const firestoreActionExists = store._actions[firestoreActionPath]\n    if (firestoreActionExists) {\n      return store.dispatch(firestoreActionPath, newPayload)\n    }\n  }\n  const mutationPath = modulePath + 'SET_' + props.toUpperCase()\n  return store.commit(mutationPath, payload)\n}\n\n/**\n * Creates a getter function in the store to set any state value\n * Usage:\n * `get('module/path/path.to.prop')`\n * it will check first for existence of: `getters['module/path/path.to.prop']`\n * if non existant it will return: `state.module.path.path.to.prop`\n * Import method:\n * `store.get = (path) => { return defaultGetter(path, store) }`\n *\n * @param   {string}   path     the path of the prop to get eg. 'info/user/favColours.primary'\n * @param   {object}   store    the store to attach\n *\n * @returns {function}          getter or state\n */\nfunction defaultGetter (path, store) {\n  const getterExists = store.getters.hasOwnProperty(path)\n  if (getterExists) return store.getters[path]\n  return getDeepValue(store.state, path)\n}\n\nexport { defaultMutations, defaultSetter, defaultGetter }\n","\nexport default {\n  setter: 'set',\n  getter: 'get',\n  vuexEasyFirestore: false\n}\n","/**\n * Vuex Easy Access plugin\n * Unified syntax with simple set() and get() store access + auto generate mutations!\n *\n * @author     Luca Ban\n * @contact    https://lucaban.com\n */\n\nimport { defaultMutations, defaultSetter, defaultGetter } from './storeAccess'\nimport defaultConfig from './defaultConfig'\nimport { getDeepRef, getKeysFromPath } from './objectDeepValueUtils'\n\nfunction createEasyAccess (userConfig) {\n  const conf = Object.assign(defaultConfig, userConfig)\n  const vuexEasyFirestore = conf.vuexEasyFirestore\n  return store => {\n    store[conf.setter] = (path, payload) => { return defaultSetter(path, payload, store, vuexEasyFirestore) }\n    store[conf.getter] = (path) => { return defaultGetter(path, store) }\n  }\n}\n\nexport default createEasyAccess\nexport { createEasyAccess, defaultMutations, defaultSetter, defaultGetter, getDeepRef, getKeysFromPath }\n"],"names":["getKeysFromPath","path","match","getDeepRef","target","keys","length","obj","shift","key","hasOwnProperty","makeMutationsForAllProps","propParent","isObject","Object","reduce","mutations","prop","propPath","toUpperCase","state","newVal","value","lastKey","pop","deepRef","join","propValue","childrenMutations","isArray","popDeepValue","push","pushDeepValue","index","deleteCount","splice","spliceDeepValue","defaultSetter","payload","store","vuexEasyFirestore","pArr","split","props","modulePath","actionPath","substring","_actions","dispatch","pathIsModule","_modulesNamespaceMap","firestoreActionPath","newPayload","mutationPath","commit","defaultGetter","getters","getDeepValue","createEasyAccess","userConfig","conf","assign","defaultConfig","setter","getter","initialState"],"mappings":"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"}